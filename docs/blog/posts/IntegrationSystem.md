---
title: 浅谈集成系统
authors: ["Misaki"]
date: 2025-03-17
categories: ["集成"]
---

简单构想一套灵活敏捷平台化的集成系统。

<!-- more -->

## 预览
~~~mermaid
%%{init: {'themeVariables': {
  'primaryColor': '#f0f0f0',
  'primaryBorderColor': '#666',
  'primaryTextColor': '#333',
  'lineColor': '#999',
  'fontFamily': 'system-ui'
}}}%%
flowchart TD
    A["用户提交构建请求"] --> B[生成YAML/JSON配置文件]
    B --> C[(版本数据库)]

    subgraph DB[数据库模块]
        C --> D[存储结构]
        D --> E["版本号 / 构建时间 / 平台"]
        D --> F["依赖库版本(MD5指纹)"]
        D --> G["构建状态"]
    end

    subgraph Build[组合构建系统]
        H[构建调度器] --> I[启动Docker容器]
        I --> J{{"Docker Registry(构建镜像)"}}
        J --> K[获取预编译产物]
        K --> L1["功能模块"]
        K --> L2["适配器模块"]
        K --> M["资源文件"]
        
        L1 --> N[集成骨架]
        L2 --> N[集成骨架]
        M --> N
        N --> O[编译Entrypoint]
        O --> P[打包Docker镜像]
    end

    subgraph Test[测试平台]
        Q[自动部署] --> R[验证测试]
        R --> S{{"压力测试"}}
        S --> T[测试报告分析]
        T --> U{通过？}
        U -->|Yes| V[生成Release]
        U -->|No| W[失败通知]
    end

    subgraph Deploy[发布系统]
        V --> X{{"Docker Registry(待发布镜像)"}}
        X --> Y["Kubernetes"]
        Y --> Z[Prometheus监控]
    end

    classDef box fill:#f8f9fa,stroke:#495057,stroke-width:1.5px
    classDef db fill:#e9ecef,stroke:#212529,stroke-dasharray:3 3
    classDef diamond fill:#ffffff,stroke:#6c757d,stroke-width:1.2px
    classDef decision fill:#ffffff,stroke:#212529,stroke-width:2px

    class DB db
    class J,J,X diamond
    class U decision
    class Build,Test,Deploy box

    style A stroke:#2b8a3e,stroke-width:1.5px
    style W stroke:#c92a2a,stroke-width:1.5px
~~~

## 0. 请求构建

为了方便思考，我们从最终发布来倒推整个流程需要哪些部件模块。将被发布的包至少需要一个可以溯源版本信息的平台，这样客户、实施、QA、开发等人员可以快速确认。于是我们需要一套数据库（例如用Mysql简单搭建一下）来记录版本信息，由于信息需要持久稳定，也许我们可以考虑高可用的数据库方案或是定期备份到仓库。

这里要保存的内容有：构建的版本、时间、平台、依赖库的版本号和MD5（或是hash值），那么这也是请求构建时需要被提交的信息。比如就用YAML或是JSON来存这些内容，方便被脚本处理。方便查看的话还可以有一个网页来查询数据库，实时查看构建状态等信息。

## 1. 组合构建

这里以容器化思路搭建，隔离性好，也比较现代。每个被提交的构建都应该在一个容器里完成，容器从各个模块仓库拉取**事先经过CI/CD验证和编译**的Release文件（库、头文件、版权信息等），也可以顺带产出拉取的文件的MD5以方便后续验证。

然后应该有一套以接口和框架为主的、尽可能抽象的集成代码，作为可执行文件（entrypoint）被编译。所有会用到的功能模块都应该是被提前编译好的，而不是在构建时编译占据大量时间和性能。

那么这里需要有一个后端来处理这些数据（也许还有鉴权），并启动构建容器和脚本来做这些事情。还会需要一个Docker Repository来存储构建环境镜像，被构建的基础镜像以及构建完的镜像。

### 1.1 功能模块

功能模块主要是实现业务的若干部分，例如一个扫码服务就需要：图像解析与处理模块、识别模块、信息后处理模块。这部分应该事先开发，并通过CI/CD完成单元测试，编译成静态库和动态库等待拉取。需要封装好，提供具体接口等待调用。

### 1.2 集成模块

集成模块包括HTTP服务模块（如果是客户端那就需要客户端代码），daemon模块（持久运行的必需品），日志模块和对接功能接口的适配器模块。其中，日志模块比较小，并且应该具备固定的接口（因为其他模块都会引入使用）。而适配器模块更像是框架，它针对不同的集成任务会出现很多版本，但这些不同的适配器模块应该具备一致的调用逻辑和封装接口，它看起来应该更像SDK，因为集成好功能模块后就得用这个模块来完成各种基础测试，到这里已经很接近一个待发布的服务包了。

适配器模块是要被接入集成骨架的，从集成骨架里调用适配器模块应该采取配置文件的编排形式，尽可能让需要定制变更的内容出现在配置文件里而不是编译到代码里。

### 1.3 集成骨架

骨架应该是一套相当稳定的代码，利用依赖注入的形式预留好API给不同模块，统一按批次的调用初始化和配置读取，按顺序启动daemon、服务等。

## 2. 测试

除了1.1里的单元测试，1.2里适配器模块的集成测试，剩下的就是整体测试了。当构建完成，现在就有了一个和用户拿到的一样的待发布版本，是时候拿到仿真环境里做最后的验证测试（理论上应该一遍过）和压力测试了。

这里可以考虑平台化，和1里提到的后端接入，自动推送部署来提高效率。测试好后把这些信息全部汇总打包归档到数据库。

## 其他

如果具备仓库能力（比如gitlab），用上jenkins，docker，k8s，nginx，mysql，jmeter，jira，那一套devops基本上就齐活了。规范做好的话，整个开发流程和效率比起开发人员本地编译打包测试发布要高效的多，信息归档也更完整好追溯。
